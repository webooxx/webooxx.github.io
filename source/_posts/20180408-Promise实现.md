---
title: Promise实现
date: 2018-04-08 22:00:18
tags: [JS,Promise,实现原理]
---



在知乎上看到一个 Promise 的简易实现教程，发现还是有点小问题，修正了下。改了个更易懂的版本


首先实现一个简易的 Promise

````js

/**
 * 简易 Promise 定义代码
 */
function Promise(){
     this.callbacks = [];
};
Promise.prototype.then  = function( fn ){
    this.callbacks.push(fn);            //  压入需要逐次调用的函数，如 [ getWeather , getSuggestion ]
    return this;
}
Promise.prototype.reslove = function( data ){
    var fn = this.callbacks.shift();    //  弹出最前面的函数
    fn && fn(data , this );             //  <---- 注意第二个参数，this  （1）
}

/**
 * 辅助函数，便于更清晰的打印日志
 */
function log( msg ){
    console.log( new Date().toLocaleString(),msg);
}


/**
 * 业务代码开始
 */
function getCity(){
    var promise = new Promise();       // 定义一个 promise 对象（2）
    setTimeout( function(){
        log('getCity : 杭州');
        promise.reslove('杭州');      //  此处调用 reslove 的时候，定义代码中的（1），则指向 promise ，即为（2）处定义的对象
    },2000);
    log('getCity ...');
    return promise;
}

function getWeather( city , promise ){      //  此处需要第二个参数 promise 来接收 Promise 对象，用以执行 reslove
    setTimeout( function(){
        log('getWeather : 晴朗');
        promise.reslove(city +'晴朗')
    },2000)
    console.log('getWeather ...');
}
function getSuggestion( cityWeather ){      //  业务逻辑结尾不需要 Promise 对象
    setTimeout( function(){
        log( cityWeather  + '建议防晒' );
    },1000)
}

getCity()
    .then(getWeather)
    .then(getSuggestion)
````


然后尝试支持 reslove、reject、catch


支持调用的格式如下

````js

getCity()
    .then( getWeather )
    .catch( onCatch )


getCity()
    .then( getWeather , getCityFail )
    .then( getSuggestion , getWeatherFail )
    .catch( onCatch )


````

改造后定义

````js

function Promise(){
     this.callbacks = [];
     this.oncatch = null;
};
Promise.prototype.then  = function( reslove , reject ){
    this.callbacks.push( {reslove:reslove,reject:reject} );
    return this;
}
Promise.prototype.reslove = function( data ){
    var handler = this.callbacks.shift();
    if( handler ){
        var fn = handler.reslove;
        fn && fn(data , this );
    }else{
        this.oncatch('没有 reslove 处理函数')
    }
}
Promise.prototype.reject = function( data ){

    var handler = this.callbacks.shift();
    var fn = handler ? handler.reject : function(){};
    fn && fn(data , this );
    this.oncatch && this.oncatch( data );
}
Promise.prototype.catch = function( fn ){
    this.oncatch = fn;
}


/**
 * 测试代码
 */

function log( msg ){
    console.log( new Date().toLocaleString(),msg);
}
function onCatch( msg ) {
    console.error( new Date().toLocaleString(),msg);
}


function getCity(){
    var promise = new Promise();
    setTimeout( function(){
        log('getCity : 杭州');
        promise.reslove('杭州');   
    },2000);
    log('getCity ...');
    return promise;
}

function getWeather( city , promise ){      //  此处需要第二个参数 promise 来接收 Promise 对象，用以执行 reslove
    setTimeout( function(){
        var sucess = Math.random() > .5 ;
        if(  sucess ){
            log('getWeather : 晴朗');
            promise.reslove('晴朗');   
        }else{
            promise.reject('getWeather 获取失败');   
        }
    },2000)
    console.log('getWeather ...');
}

function getSuggestion( cityWeather ){      //  业务逻辑结尾不需要 Promise 对象
    setTimeout( function(){
        log( cityWeather  + '建议防晒' );
    },1000)
}

getCity()
    .then( getWeather )
    .catch( onCatch )

getCity()
    .then( getWeather , onCatch )


getCity()
    .then( getWeather , onCatch )
    .then( getSuggestion , onCatch )
    .catch( function( msg ){
        onCatch('final catch , '+ msg);

    } )


getCity()
    .then( getWeather  )
    .then( getSuggestion  )
    .catch( function( msg ){
        onCatch('final catch , '+ msg);

    } )
````

转换为现代点的 class 定义，转换后的代码依然可以使用之前的测试代码，结果一致

````js
class Promise {

    constructor() {
        this.callbacks = [];
        this.oncatch = null;       
    }
    then( reslove , reject ){
        this.callbacks.push( {reslove:reslove,reject:reject} );
        return this;
    }
    reslove( data ){
        let handler = this.callbacks.shift();
        if( handler ){
            let fn = handler.reslove;
            fn && fn(data , this );
        }else{
            this.oncatch('没有 reslove 处理函数')
        }
    }
    reject( data ){
        let handler = this.callbacks.shift();
        let fn = handler ? handler.reject : function(){};
        fn && fn(data , this );
        this.oncatch && this.oncatch( data );
    }
    catch( fn ){
        this.oncatch = fn;
    }

}
````
